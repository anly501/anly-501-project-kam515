---
title: "Lab 1 Assignment"
author: "Katie Mead"
output: rmdformats::robobook
---

```{r}
library(ggplot2)
library(ISwR)
```

One of the primary advantages of simulators is that they are able to provide users with practical feedback
when designing real world systems. This allows the designer to determine the correctness and efficiency of a
design before the system is actually constructed.
That means we do simulations to imitate real situations and fit models to check the robustness of our models
and then fit those models on real data. This is a famous method on big research areas.

# Problem 1 - Guided Activity

Take the 6-sided fair dice (or simulated [dice]<https://www.piliapp.com/random/dice/?num=1>) and roll until you reach your first three successes (_*rolling a 1*_).

Do you think the _success probability is p = 1/6 or better?_
Can a simulation give an answer? lets try.

a) Count how many trials it takes to get your first, second, and third success (_*rolling a 1*_).

It took six attempts to roll 1 one time. I got it a second time on the seventh roll. It took until the seventeenth roll to get the third success.

b) Create two functions taking in a success probability: 'myroll' to simulate a single dice roll and 'myattempts' to find the number of failures until the first success (Hint: We have already done this in the Lab )
```{r}

myroll = function(p){
  u <- runif(1)
  x <- as.numeric(u < p) #when p is the larger number, there is a higher chance of being this argument true.
  return(x)
}

myroll(1/6)

myattempts = function(p){ counter <- 0
while (myroll(p) == 0){ counter <- counter + 1 }
return(counter) }

myattempts(1/6)
```

c) Simulate the number of rolls needed to get to three successes, use the success probability p = 1/6. (use the "myattempts" function). Assign this number to be x. (Hint: Run many simulations (say 10,000) with this success probability to find the number of failures until first three successes.)
```{r}

x = sum(replicate(3, myattempts(1/6)))
x 
y = replicate(10000, sum(replicate(3, myattempts(1/6))))
head(y)

```

d) Find the fraction of simulations where three successes were reached after the number of trials it took you to get three successes - with success probability 1/6. (Use the "x" variable from part 2). In other words, what percentage of the simulations did worse than the number of trials it took you to get three successes? (Hint: So now we want to find the probability of getting 3 successes after 9 tosses, that means probability of total of 6 or more tosses until I get my 3 successes)
```{r}

z = replicate(10000, as.numeric(17<sum(replicate(3, myattempts(1/6)))))

mean(z)
```

# Problem 2 - Theoretical Questions for Discussion

In your groups take notes and discuss on the following:

a) What does it mean to set seed? How could it be useful to the study of probability and statistics?
Setting seed means to set a particular number as the initial value of generating random numbers. It also allows this number to stay the same over time so that this same number can be used for future analyses. This could be helpful because it simulates stochastic processes.

b) How might you run a similar simulation in python? are there any functions comparable to the ones used in problem #1 and #2?
I would run a similar simulation in python by using the random function in base python with the numbers 1 through 6.

c) Reflect on your experiences during the boot camp this summer. What might be some advantages/disadvantages of R over Python?
Based on my experiences in the bootcamp, R has a powerful set of statistical analysis tools, while I find Python is better for writing algorithms. However, I am looking forward to learning more about both languages to see what each does better.



# Problem 3

Problem 1.5 in ch. 1 of Dalgaard. On p. 27, replicate was used to simulate the distribution of the mean of 20 random numbers from the exponential distribution by repeating the operation 10 times. That code is

```{r}
replicate(10,mean(rexp(20)))
```

How would you do the same thing with `sapply`?

```{r}
data = replicate(10,mean(rexp(20)))

sapply(data, FUN = "mean")

```
